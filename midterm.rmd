---
title: "CPLN 675 Midterm"
author: "Marquise Williams and Will Friedrichs"
date: "3/29/2022"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    runtime: shiny
---

For this project, a generalized linear model will be used to predict flood inundation zones first in Calgary, then in Sacramento County. For each area, predictions will estimate whether or not a given 500m by 500m "cell" of area can be described as in a flood inundation zone. This prediction process is described in four steps: data gathering, building variables, logistic metrics, and goodness of fit metrics.

```{r setup, include=TRUE,message = FALSE,cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)
sf::sf_use_s2(FALSE)
options(scipen=999)
library(caret)
library(pscl)
library(plotROC)
library(pROC)
library(sf)
library(tidyverse)
library(knitr)
library(kableExtra)
library(tigris)
library(viridis)
```


### 1) Data Gathering

The following factors will be examined as predictors of Calgary's flood inundation zones.

<code>cal_dem</code>, <code>sac_dem</code>: For Calgary and Sacramento County respectively, <code>cal_dem</code> and <code>sac_dem</code> represent elevation data relative to the lowest point in the area. Flood inundation is probably more likely in low-lying areas than high elevation areas, so there is reason to suspect this factor might be significant.

<code>cal_streamdist</code>, <code>sac_streamdist</code>: For Calgary and Sacramento County respectively, <code>cal_streamdist</code> and <code>sac_streamdist</code> describe the distance between any cell and a stream. This is due to our hypothesis that areas with streams have a higher flooding susceptibility. 

Additionally, the the type of land cover may also factor into whether an area is susceptible to flooding. For example certain land uses, such as commercial or industrial may allow for greater soil impermeability than others, which increases vulnerability to flooding in some urban contexts without proper drainage. 


For comparative reasons, land uses have been condensed into five land use zones categories for Calgary & Sacramento County: 

<code>sac_residcover</code>: describes areas of Sacramento County with residential land uses,
<code>sac_mixedcover</code>: describes areas of Sacramento County with mixed Use or transit orientated development land uses,
<code>sac_commecover</code>: describes areas of Sacramento County with commercial land uses,
<code>sac_induscover</code>: describes areas of Sacramento County with industrial land uses,
<code>sac_agricover</code>: describes areas of Sacramento County with agricultural & open space land uses,  

<code>cal_residcover</code>: describes areas of Calgary with residential land uses,
<code>cal_mixedcover</code>: describes areas of Calgary with mixed Use or transit orientated development land uses,
<code>cal_commecover</code>: describes areas of Calgary with commercial land uses, 
<code>cal_induscover</code>: describes areas of Calgary with industrial land uses, &
<code>cal_agricover</code>: describes areas of Calgary with agricultural & open space land uses 

<code>cal_treecover</code> and <code>sac_treecover</code> also are used to describe the tree cover within Calgary and Sacramento County receptively. The presence of tree density may play a factor in water absorption as well as soil permeability.

NEED DISTANCE TO RIVER AS ADDITIONAL FACTORS HERE
```{r load_geojson, warning = FALSE, message=FALSE}
##Sacramento & Calgary Land Use Variables

sac_residcover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/SacFN_New_Resi_UPDATED.json", quiet = TRUE) ##Residential land Use

sac_mixedcover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/SacFN_New_mixed_filled.geojson", quiet = TRUE) ## Mixed Use/ Transit Orientated Development Land Use

sac_commecover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/SacFN_New_mixed_filled.geojson", quiet = TRUE) ## Commercial Land Use

sac_induscover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/SacFN_New_industrial_filled.geojson", quiet = TRUE) ##Industrial Land Use

sac_agricover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/SacFN_New_argric_filled.geojson", quiet = TRUE) ## Agricultural & Open Space Land Use

## Calgary Land Use
cal_residcover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/CalgaryFishnet_resid.json", quiet = TRUE)  ##Residential land Use

cal_mixedcover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/CalgaryFishnet_mixed.json", quiet = TRUE) ## Mixed Use/ Transit Orientated Development Land Use

cal_commecover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/CalgaryFishnet_commer.json", quiet = TRUE) ## Commercial Land Use

cal_induscover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/CalgaryFishnet_industr.json", quiet = TRUE) ##Industrial Land Use

cal_agricover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/CalgaryFishnet_agric.json", quiet = TRUE) ## Agricultural & Open Space Land Use


## Tree Cover
cal_treecover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/CalgaryFishnet_TreeCover__.json", quiet = TRUE)  ##Residential land Use

sac_treecover <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/SacFN_New_TreeCover.json", quiet = TRUE) ##Agricultural & Open Space Land Use

```

```{r load_json, warning = FALSE, message = FALSE}
cal_dem <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/Cal_dem_filled.json", quiet = TRUE)

cal_streamdist <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/cal_dist2streams.json", quiet = TRUE)

cal_inundation <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/calgary_inundation.json", quiet = TRUE)

cal_inundation[is.na(cal_inundation)] = 0

sac_dem <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/sac_dem_filled.geojson", quiet = TRUE)

sac_streamdist <- st_read("https://raw.githubusercontent.com/Willfriedrichs/Midterm_Repo/main/Finalized_Layers/sac_dist2streams.geojson", quiet = TRUE)
```

<code>cal_inundation</code>: This is what our model aims to predict. We will train our model on part of Calgary flood inundation fishnet, and test our predictions on another part of it.

### 2) Building Variables and Running Model


In this step, the variables are joined together to form one table that includes each of the independent variables and the dependent variable. Variables will also be adjusted for better comparison across regions. For example, some variables only need their geometry and the metric that is measures such as mean distance to stream from any given cell or majority of land use type for cells. This is done for variables pertaining to Calgary and Sacramento.

```{r load_chesco, warning = FALSE, message = FALSE}
##Calgary Model

# cal_dem only needs its geometry and information as to the mean elevation of each cell.
# mean elevation will be re-evaluated relative to minimum non-zero fishnet cell
cal_dem = cal_dem %>% select(ZonalSt_Fishnet1.MEAN)
min_nonzero_cell = min(cal_dem$ZonalSt_Fishnet1.MEAN)
cal_dem$ZonalSt_Fishnet1.MEAN = cal_dem$ZonalSt_Fishnet1.MEAN - min_nonzero_cell

#cal_streamdist only needs its geometry and the mean distance to stream from any given cell.
cal_streamdist = cal_streamdist %>% select(dist2streams.MEAN)

#cal_inundation only needs its geometry and the majority inundation for cells
cal_inundation = cal_inundation %>% select(calgary_inundation.MAJORITY)

#cal_residcover only needs its geometry and the majority of the areas pertaining to residential land use for cells
cal_residcover = cal_residcover %>% select(ZonalSt_Calgary1_MAJORITY)

#cal_mixedcover only needs its geometry and the majority of the areas pertaining to mixed Use or transit orientated development land use for cells
cal_mixedcover = cal_mixedcover %>% select(ZonalSt_Calgary2_MAJORITY)

#cal_commecover only needs its geometry and the majority of the areas pertaining to  commercial land uses for cells
cal_commecover = cal_commecover %>% select(ZonalSt_Calgary3_MAJORITY)

#cal_induscover only needs its geometry and the majority of the areas pertaining to industrial land uses for cells
cal_induscover = cal_induscover %>% select(ZonalSt_Calgary4_MAJORITY)

#cal_agricover only needs its geometry and the majority of the areas pertaining to  agricultural & open space land uses for cells
cal_agricover = cal_agricover %>% select(ZonalSt_Calgary5_MAJORITY)

#cal_treecover only needs its geometry and the count of trees in the area for each cell 
cal_treecover = cal_treecover %>% select(ZonalSt_Calgary6_COUNT)

##Sacramento Model

# sac_dem only needs its geometry and information as to the mean elevation of each cell.
# since the minimum mean elevation is nonzero in Sacramento, no readjustment is necessary.
sac_dem = sac_dem %>% select(demFilledSAC.MEAN)

#sac_streamdist only needs its geometry and the mean distance to stream from any given cell.
sac_streamdist = sac_streamdist %>% select(dist2streamsSAC.MEAN)

#sac_residcover only needs its geometry and the majority of the areas pertaining to residential land use for cells
sac_residcover = sac_residcover %>% select(ZonalSt_SacFN_N7_MAJORITY)

#sac_mixedcover only needs its geometry and the majority of the areas pertaining to mixed Use or transit orientated development land use for cells
sac_mixedcover = sac_mixedcover %>% select(ZonalSt_SacFN_N2_MAJORITY)

#sac_commecover only needs its geometry and the majority of the areas pertaining to  commercial land uses for cells
sac_commecover = sac_commecover %>% select(ZonalSt_SacFN_N2_MAJORITY)

#sac_induscover only needs its geometry and the majority of the areas pertaining to industrial land uses for cells
sac_induscover = sac_induscover %>% select(ZonalSt_SacFN_N4_MAJORITY)

#sac_agricover only needs its geometry and the majority of the areas pertaining to  agricultural & open space land uses for cells
sac_agricover = sac_agricover %>% select(ZonalSt_SacFN_N5.MAJORITY)

#sac_treecover only needs its geometry and the count of trees in the area for each cell 
sac_treecover = sac_treecover %>% select(ZonalSt_SacFN_N5_COUNT)

# Once in a single dataframe, discard OIDs and rename variables
##All Calgary
allCalgary = st_join(cal_dem, cal_streamdist, largest = TRUE) %>%
             st_join(cal_inundation, largest = TRUE) %>%
            ######### st_join(sac_streamdist, largest = TRUE) %>%     


allCalgary = allCalgary %>% rename(meanElevation = ZonalSt_Fishnet1.MEAN,
                                   meanStreamDistance = dist2streams.MEAN,
                                   inundation = calgary_inundation.MAJORITY)

ggplot() +
  geom_sf(data=allCalgary, aes(fill=as.factor(inundation))) +
  labs(title="cal_inundation")
```

The variables are now ready to be split into training and test sets, and finally, added to the linear model. The <code>set.seed()</code> and <code>createDataPartition</code> functions help to randomly select a portion (in this case 70% of cells) to join the training set. The rest form the test set.

```{r training_set}
# Randomly separate data into 70% training set, 30% test set
set.seed(3456)
trainIndex <- createDataPartition(allCalgary$inundation, p = .70,
                                  list = FALSE,
                                  times = 1)

allCalgaryTrain <- allCalgary[ trainIndex,]
allCalgaryTest  <- allCalgary[-trainIndex,]
```
                     
The <code>glm()</code> takes in the independent variables and dependent from a portion of the dataset and produces a formula that minimizes prediction error. The formula's performance predicting the dependent variables in the test set can be used to characterize the performance of the model in Calgary. It can also be used to predict inundation given the previously outlined independent variables in other locations, such as Sacramento.

```{r create_model, warining = FALSE, message = FALSE}
# Convert to regular dataframe, R cannot run a regression on an sf
inundationModel <- glm(inundation ~ ., 
                    family="binomial"(link="logit"), data = allCalgaryTrain %>%
                                                            as.data.frame() %>%
                                                            select(-geometry))
```


### 3) logistic metrics

```{r logistc_metrics, warining = FALSE, message = FALSE}
# Get summary statistics for the inundationModel
summary(inundationModel)
```

The model output, as displayed by the <code>summary()</code> function, shows the coefficients of the model. This is mathematically what produces inundation predictions by cell. The coefficients of <code>meanElevation</code> and <code>meanStreamDistance</code> are both negative, meaning that the greater these values get, the lower the chance a given cell will be predicted to be in an inundation zone. This makes sense, as low elevation and low distance to streams pose greater flood risks.

HERE WE NEED TO ADD MORE ANALYSIS REGARDING OUR MODEL'S OUTPUT

HERE WE NEED TO ADD MORE ABOUT THE P VALUE OF THE DIFFERENT FACTORS

MAYBE WE ALSO CAN COME BACK TO THIS AND DO A LITTLE MORE WITH EXPONENTIATION; THE TEXT BETWEEN THE LINES IS FROM THE PA RESERVATION WEEK 7 EXERCISE RMD
_________
But for the record, the way the coefficients in a logistic regression are interpreted is different than in OLS - we are talking in terms of "odds" of an outcome occurring (in our case odds of land being preserved.). If we exponentiate the coefficient (`exp()`) we can interpret it as *all else equal* the exponentiated value being the increase or decrease in the odds of the outcome.
_________

The <code>inundationModel</code> can be used to predict for any geographic cells given the previously specified independent variables with the <code>predict()</code> function. In this case, the model will be used to predict for the test set. The output, <code>inundationProbability</code>, will describe the model's prediction of the likelihood that each cell will be in an inundation zone.

The histogram below demonstrates that the great majority of tracts are predicted to have a low likelihood of being in an inundation zone. This makes sense, because within Calgary city limits, based on the training set, most cells of land were not in an inundation zone.

```{r predict_calgary_test}
# Get the results of the model on the Test set, create a histogram of the probability
# The parameter type="response" ensures that the probabilities range from 0 to 1.
inundationTrainProb <- predict(inundationModel, allCalgaryTest, type="response")

hist(inundationTrainProb)
```

The two charts below display inundation predictions for the test set. The first chart shows predictions for cells that ended up being non-inundation (0) zones, and the second chart shows predictions for inundation (1) zone cells. The y-axis describes quantities of predictions produced for each level of probability.

The model generally predicted much lower probabilities in actual non-inundation zones. In actual inundation zones, THIS NEEDS TO BE CONTINUED WHEN MORE ELEMENTS ARE ADDED TO THE MODEL


```{r plot_preds}
inundationTestProb <- data.frame(obs = as.numeric(allCalgaryTest$inundation),
                        pred = inundationTrainProb)

ggplot(inundationTestProb, aes(x = pred, fill=as.factor(obs))) + 
  geom_density() +
  facet_grid(obs ~ .) + 
  xlab("Probability") + 
  geom_vline(xintercept = .5) +
  scale_fill_manual(values = c("dark green", "dark blue"),
                      labels = c("No inundation zone predicted","Inundation zone predicted"),
                      name = "") + 
  labs(title="Test set: predicted probabilities by actual inundation zone status")
```

### 4) Goodness of fit metrics and cross validation

Goodness of fit metrics quantify a models predictive performance. A confusion matrix takes predictions and true values and delivers the count of true negatives, false negatives, true positives, and false positives. 

In order to create a confusion matrix, a threshold for predicting the dependent variable must be selected. A threshold of 50% means that when the model delivers a prediction of 0.5 or more, it becomes a prediction of an inundation zone.

A threshold of 0.15 is selected for the confusion matrix below.

```{r confusion_matrix, message = FALSE, warning = FALSE}
inundationTestProb$predClass  = ifelse(inundationTestProb$pred > .15 ,1,0)

caret::confusionMatrix(reference = as.factor(inundationTestProb$obs), 
                       data = as.factor(inundationTestProb$predClass), 
                       positive = "1")
```

Due to the low likelihood of inundation predicted by the model for all zones, a low threshold is necessary to achieve any sensitivity (true positivity). This means some specificity is sacrificed, as more non-inundation zones are labeled as inundation zones.

An ROC or "Reciever Operating Characteristic" curve is anther metric that describes a model's goodness of fit. It measures the relationship between sensitivity (True positive fraction) and specificity (false positive fraction) at different levels of prediction threshold. On the chart below, the black line is the performance of the model, and it is compared to a gray line that represents a hypothetical "coin flip" model.

```{r roc_curve, message = FALSE, warning = FALSE}

ggplot(inundationTestProb, aes(d = obs, m = pred)) + 
  geom_roc(n.cuts = 50, labels = FALSE) + 
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') 
```

The AUC (Area Under Curve) measures the models ability to make distinctions between the two classes, in this case non-inundation and inundation zones on a fishnet.
  
```{r auc, warning = FALSE}
auc(inundationTestProb$obs, inundationTestProb$pred)
```

Cross validation tests the model on different combinations of data other than just a single test set. In this instance, the model will run across 100 different divisions of test and training sets. The histogram below notes the accuracy of the model on each fold. The results show a consistent level of accuracy, slightly above 0.95 out of 1.0.


```{r k_fold, warning = FALSE, message = FALSE}
ctrl <- trainControl(method = "cv", 
                     number = 100, 
                     savePredictions = TRUE)

cvFit <- train(as.factor(inundation) ~ .,  data = allCalgaryTrain %>% 
                 as.data.frame() %>%
                 select(-geometry), 
               method="glm", family="binomial",
               trControl = ctrl)

ggplot(as.data.frame(cvFit$resample), aes(Accuracy)) + 
  geom_histogram(bins=100) +
  scale_x_continuous(limits = c(0, 1)) +
  labs(x="Accuracy",
       y="Count")
```

NEED TO GO BACK AND TIDY UP THESE GRAPHS. 
NEED TO EXPLAIN SPATIAL CV.
NEED TO GO AND MAKE COMMENTS ON THE CODE BELOW

```{r spatial_CV, warning = FALSE, message = FALSE}
library(mlr)

# https://www.r-bloggers.com/2018/07/visualization-of-spatial-cross-validation-partitioning/
# https://geocompr.robinlovelace.net/spatial-cv.html

# create a resampling description with parameters on how we will resample our data for the cross validation. 
rdesc = makeResampleDesc("SpRepCV", folds = 5, reps = 4)

factorized_training = st_drop_geometry(allCalgaryTrain)
factorized_training$inundation = as.factor(factorized_training$inundation)

calgaryTrainingTask = makeClassifTask(data = factorized_training,
                                      target = "inundation",
                                      coordinates = as.data.frame(st_coordinates(st_centroid(allCalgaryTrain)))
)


resamp = resample(makeLearner("classif.qda"), calgaryTrainingTask, rdesc)

plots = createSpatialResamplingPlots(calgaryTrainingTask, resamp, crs = 4326,
  repetitions = 2)
plots

sp_cv = mlr::resample(makeLearner("classif.qda"), calgaryTrainingTask, rdesc, measure = acc)
summary(sp_cv$measures.test$acc)

```
